https://www.youtube.com/watch?v=S-RjiMAxHio&list=PLmqFxxywkatStbd9hdzVOS1hZa9dc56k4&index=2&ab_channel=SergeyNemchinskiy

GRASP - General Responsibility Assignment Software Patterns

Последовательность вывода принципов:
OOP -> GRASP -> GoF


GRASP паттерны:


1) Information Expert - система должна обрабатывать информацию. Какая часть системы это делает? Та, в которой это содержится!
Стоимость чека (посчитать сумму) - вода - 1$, сыр - 5$, молоко - 2$.
Order <-> OrderItem (good, amount) <-> Good (price)
OrderItem считает сумму за Good, а Order уже считает сумму OrderItem-а!


2) Creator - объекты класса должны быть созданы КЛАССОМ, который ПОЛЬЗУЕТСЯ ИМ. Делаем это через метод - КОНСТРУКТОР!
Order <-> OrderItem (good, amount) <-> Good (price)
ПРОБЛЕМА: Client -> Order order = new Order(). order.add(new OrderItem()); А в OrderItem ещё и Good нужно засунуть! Много зависимостей!
РЕШЕНИЕ: Order в своём конструкторе создаёт OrderItem, а OrderItem в своём конструкторе создаёт Good


3) Controller - кто обрабатывает входные системные события? Либо локализовать, либо на всю систему.
Контроллер - говорит что вся обработка должна аккумулироваться в одном месте.
100500+ потоков (многопоточность) -> Контроллер (превращает многопоточность в 1 поток) -> Бизнес Логика (Теперь в 1 поток работает)
Контроллер просто конвертирует многопоточность в однопоточность, ставя в очередь / отказы и т.д.
Правило контроллера: Бизнес Логика должна быть ОДНОПОТОЧНОЙ!
В Контроллер можно напихать следующее: логирование, аутентификацию, авторизацию, кеширование и т.д.
И Контроллеры можно подменять на другие.
Недостаток: Контроллер может оказаться слишком перегруженным. Решение: Превратить Контроллер в package - может использовать полиморфизм и т.д.


4) Low coupling - низкая связанность. Нам нужно меньше связей между объектами.
Для обеспечения меньшей связанности нужно распределить обязанности между объектами, то есть зарефакторить код.
ПРОБЛЕМА:   Регистрация -> создать() -> Продажа
            Регистрация -> добавитьПлатёж() -> Платеж
РЕШЕНИЕ:    Регистрация -> оплатить() -> Продажа -> создать() -> Платёж
Смысл такой: Как можно меньше стрелок к каждой отдельной сущности.


5) High Cohesion - высокое зацепление. Нам нужно чтобы каждый класс отвечал ТОЛЬКО ЗА ОДНУ ФУНКЦИЮ (он же SRP).
Класс в отдельности должен быть хорошо логически внутри зацеплен. Всё лишнее изгоняется в другие классы.
То есть сам по себе класс должен быть как можно более независимым от других внешних объектов и методов.
Класс с High Cohesion-ом становится прост в поддержке и повторном использовании. Логично, ведь классы, которые следуют SRP более гранулярны.
НО! Иногда ТЯЖЁЛЫЙ КЛАСС лучше отправить из Бизнес Логики и вынести его в отдельный класс, даже если он был частью класса.
Как увидеть класс, где проблема с High Cohesion:
- Когда есть префиксы:
class DateTemp
    dateDiff
    dateAdd
    tempDiff
    tempAdd
Simply put, it means “the code that changes together, stays together”.


6) Polymorphism - более низкая определение полиморфизма из ООП.
Части системы в проекте распределяются и обычно обрабатываются при помощи if-ов, switch-ей. НО! У нас есть ПОЛИМОРФИЗМ!
В клиентском коде лучше использовать абстракцию (абстрактный класс или интерфейс), чтобы клиент меньше бухтел с имплементациями.
ВАЖНО! Если заранее неизвестно, что будет несколько имплементаций или нет обобщённых методов, то
НЕ НАДО ЗЛОУПОТРЕБЛЯТЬ этим принципом С ЦЕЛЬЮ ПРИМЕНЕНИЯ ПОЛИМОРФИЗМА! То есть когда УЖЕ ЕСТЬ 2+ имплементации!
Если 1 имплементация, то интерфейс можно добавить.


7) Pure Fabrication - объект, который нельзя представить никак в реальном мире.
То есть синтезировать искусственную сущность для Low Coupling-а и High Cohesion-а.


8) Indirection - обеспечение отсутствия прямого связывания. Клиент скачет от интерфейса, а реализацию всегда подменить.
То есть мы можем переиспользовать любой кусок кода в системе.
Client -> IService -> Service, где
Клиентский package: Client -> IService
Серверный package: IService -> Service
Из Indirection-а как раз выводится Полиморфизм...


9) Protected Variations - или защищённые изменения.
Обеспечение устойчивой работы системы при помощи идентификации точки возможных изменений.
Точка неустойчивости - точка, куда вносятся постоянно изменения. Что это значит? Это значит, что она ПЛОХО НАПИСАНА.
Она не позволяет лего себя изменять, не изменяя кода.
Как обычно выглядит эта точка? Ну, класс, где большая ветка if / else if-ов. Мы туда постоянно вносим изменения. Фиксится полиморфизмом бтв...


*) Low Coupling и High Cohesion - это прямой вывод из ООП, а именно: Инкапсуляции
*) ВАЖНО! Интерфейс является ПРИНАДЛЕЖНОСТЬЮ КЛАССА, который его ВЫЗЫВАЕТ, а не РЕАЛИЗУЕТ!
То есть думать об удобстве интерфейса надо с точки зрения его ВЫЗОВА, а не ИМПЛЕМЕНТАЦИИ.

